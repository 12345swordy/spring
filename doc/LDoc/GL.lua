--- OpenGL and drawing related
-- @module GL

--- GLSL
-- @section glsl
-- These functions are ONLY available if the graphics adapter supports GLSL.
--
-- Please test in your scripts if one of them exists before you use them. In headless mode, the gl. callouts are nil.

--- Create a shader from shaderParams table:
-- @function gl.CreateShader ( table shaderParams )
-- @tparam table shaderParams
-- @treturn number shaderID
--
--    ({[ vertex   = "glsl code" ,]
--      [ tcs      = "glsl code" ,]
--      [ tes      = "glsl code" ,]
--      [ geometry = "glsl code" ,]
--      [ fragment = "glsl code" ,]
--      [ uniform       = { uniformName = number value, ...} ,] (specify a Lua array as an argument to uniformName to initialize GLSL arrays)
--      [ uniformInt    = { uniformName = number value, ...} ,] (specify a Lua array as an argument to uniformName to initialize GLSL arrays)
--      [ uniformFloat  = { uniformName = number value, ...} ,] (specify a Lua array as an argument to uniformName to initialize GLSL arrays)
--      [ uniformMatrix = { uniformName = number value, ...} ,]
--      [ geoInputType = number inType,]
--      [ geoOutputType = number outType,]
--      [ geoOutputVerts = number maxVerts,]
--      [ definitions = "string of shader #defines", ]
--    })
-- 
-- - The "Vertex" or vertex-shader is your GLSL-Code as string, its written in a C-Dialect. This shader is busy deforming the geometry of a unit but it can not create new polygons. Use it for waves, wobbling surfaces etc.
-- - The "Geometry" or Geometry-shader can create new vertices and vertice-stripes from points.
-- - The "TCS" or Tesselation Control Shader controls how much tessellation a particular patch gets; it also defines the size of a patch, thus allowing it to augment data. It can also filter vertex data taken from the vertex shader. The main purpose of the TCS is to feed the tessellation levels to the Tessellation primitive generator stage, as well as to feed patch data (as its output values) to the Tessellation Evaluation Shader stage.
-- - The "TES" or Tesselation Evaluation Shader takes the abstract patch generated by the tessellation primitive generation stage, as well as the actual vertex data for the entire patch, and generates a particular vertex from it. Each TES invocation generates a single vertex. It can also take per-patch data provided by the Tessellation Control Shader.
-- - The "Fragment" or Fragment-shader (sometimes called pixel-Shader) is post processing the allready rendered picture (for example drawing stars on the sky)- remember textures are not always 2 dimensional pictures. They can contain information about the depth, or the third value marks areas and the strength at which these are processed.
-- - The Uniforms are the values, you send along with the shader-program. To use them in the shader-program declare them like this: `uniform float frame;`
--
-- From 101.0 onwards, the engine will automatically fill in an appropriately named uniform for team colour if it is declared;
--
--    uniform vec4 teamColor;
--

--- Deletes a shader identified by shaderID
-- @function gl.DeleteShader
-- @number shaderID
-- @treturn nil

--- Binds a shader program identified by shaderID, and calls the Lua func with the specified arguments.
-- Can be used in NON-drawing events (to update uniforms etc.)!
-- @function gl.ActiveShader
-- @number shaderID
-- @func func
-- @tparam[opt] any arg1
-- @tparam[opt] any arg2
-- @tparam[opt] any argn
-- @treturn nil

--- Binds a shader program identified by shaderID. Pass 0 to disable the shader. Returns wether the shader was successfully bound.
-- @function gl.UseShader
-- @number shaderID
-- @treturn bool linked

--- Returns the shader compilation error log. This is empty if the shader linking failed, in that case, check your in/out blocks and ensure they match.
-- @function gl.GetShaderLog
-- @treturn string infoLog

--- Sets the Geometry shader parameters for shaderID. Needed by geometry shader programs (check the opengl GL_ARB_geometry_shader4 extension for glProgramParameteri)
-- @function gl.SetGeometryShaderParameter
-- @number shaderID
-- @number param
-- @number number
-- @treturn nil

--- Sets the tesselation shader parameters for shaderID. Needed by tesselation shader programs (check the opengl GL_ARB_tessellation_shader extension for glProgramParameteri)
-- @function gl.SetTesselationShaderParameter
-- @number param
-- @number number
-- @treturn nil

--- Query the active (actually used) uniforms of a shader and identify their names, types (float, int, uint) and sizes (float, vec4, ...).
-- @function gl.GetActiveUniforms
-- @number shaderID
-- @treturn table `ActiveUniforms = { { name = "name", type = "type", length = number length, size = number size }, ...}`

--- Returns the locationID of a shaders uniform. Needed for changing uniform values with @function gl.Uniform.
-- @function gl.GetUniformLocation
-- @number shaderID
-- @string name
-- @treturn number locationID

--- Sets the uniform float value at the locationID for the currently active shader. Shader must be activated before setting uniforms.
-- @function gl.Uniform
-- @number locationID
-- @number f1
-- @number[opt] f2
-- @number[opt] f3
-- @number[opt] f4
-- @treturn nil

--- Sets the uniform int value at the locationID for the currently active shader. Shader must be activated before setting uniforms.
-- @function gl.UniformInt
-- @number locationID
-- @number int1
-- @number[opt] int2
-- @number[opt] int3
-- @number[opt] int4
-- @treturn nil

--- Sets the an array of uniform values at the locationID for the currently active shader. Shader must be activated before setting uniforms. Type can be one of {1 = int, 2 = float, 3 = float matrix}. In 104.0 the maximum length of the uniforms table increased from 32 entries to 1024.
-- @function gl.UniformArray
-- @number locationID
-- @number type
-- @tparam table uniforms
-- @treturn nil

--- Sets the a uniform mat4 locationID for the currently active shader. Shader must be activated before setting uniforms. Can set one one common matrix like shadow, or by passing 16 additional numbers for the matrix.
-- @function gl.UniformMatrix
-- @number locationID
-- @tparam ?string|number m1 "shadows" | "camera" | "caminv" | "camprj"
-- @number[opt] m2
-- @number[opt] mn
-- @number[opt] m16
-- @treturn nil

--- FBO
-- @section fbo

--- @table attachment
-- attachment ::= luaTex or RBO or nil or { luaTex [, num target [, num level ] ] }

--- User Data FBO
-- @table fbo
-- @tparam attachment depth
-- @tparam attachment stencil
-- @tparam attachment color0
-- @tparam attachment color1
-- @tparam attachment color2
-- @tparam attachment colorn
-- @tparam attachment color15
-- @tparam table drawbuffers `{ GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT3_EXT, ..}`
-- @tparam table readbuffer `GL_COLOR_ATTACHMENT0_EXT`

--- @function gl.CreateFBO
-- @param data
-- @tparam attachment data.depth
-- @tparam attachment data.stencil
-- @tparam attachment data.color0
-- @tparam attachment data.color1
-- @tparam attachment data.color2
-- @tparam attachment data.colorn
-- @tparam attachment data.color15
-- @tparam table data.drawbuffers `{ GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT3_EXT, ..}`

--- @function gl.DeleteFBO
-- This doesn't delete the attached objects!
-- @tparam fbo fbo

--- @function gl.IsValidFBO
-- @tparam fbo fbo
-- @number[opt] target
-- @treturn bool valid
-- @treturn ?number status

--- @function gl.ActiveFBO
-- @tparam fbo fbo
-- @number[opt] target
-- @bool[opt] identities
-- @func[opt] lua_function
-- @param[opt] arg1
-- @param[opt] arg2
-- @param[opt] argn

--- Binds a FBO like `gl.ActiveFBO` does, but you have to unbind it yourself!
-- @function gl.UnsafeSetFBO
-- @tparam ?fbo|nil fbo
-- @number[opt] target `GL_FRAMEBUFFER_EXT|fbo.target`

--gl.RawBindFBO (Replaces UnsafeSetFBO starting from 104.0.1-1003-gb3e02a6 maintenance)
--
-- ( nil [, number target = GL_FRAMEBUFFER_EXT ] [, number rawFboId = 0] ) -> nil (Bind default or specified via rawFboId numeric id of FBO)
-- ( fbo [, number target = fbo.target ] ) -> number previouslyBoundRawFboId

--- needs `GLEW_EXT_framebuffer_blit`
-- @function gl.BlitFBO
-- @number x0Src
-- @number y0Src
-- @number x1Src
-- @number y1Src
-- @number x0Dst
-- @number y0Dst
-- @number x1Dst
-- @number y1Dst
-- @number[opt=GL_COLOR_BUFFER_BIT] mask
-- @number[opt=GL_NEAREST] filter

--- needs `GLEW_EXT_framebuffer_blit`
-- @function gl.BlitFBO
-- @tparam fbo fboSrc
-- @number x0Src
-- @number y0Src
-- @number x1Src
-- @number y1Src
-- @tparam fbo fboDst
-- @number x0Dst
-- @number y0Dst
-- @number x1Dst
-- @number y1Dst
-- @number[opt=GL_COLOR_BUFFER_BIT] mask
-- @number[opt=GL_NEAREST] filter

--- RBO
-- @section rbo

--- User Data RBO
-- @table rbo
-- @number target
-- @number format
-- @number xsize
-- @number ysize
-- @bool valid
-- @number samples will return globalRendering->msaaLevel for multisampled RBO or 0 otherwise

--- @function gl.CreateRBO
-- @number xsize
-- @number ysize
-- @tparam table data
-- @number data.target `GL_RENDERBUFFER_EXT`
-- @number data.format `GL_RGBA`
-- @number[opt] data.samples any number here will result in creation of multisampled RBO

--- @function gl.DeleteRBO
-- @tparam rbo rbo
