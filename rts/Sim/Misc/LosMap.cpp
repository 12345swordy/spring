/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */

#include "LosMap.h"
#include "LosHandler.h"
#include "Map/ReadMap.h"
#include "System/myMath.h"
#include "System/float3.h"
#include "System/Log/ILog.h"
#include "System/Util.h"
#ifdef USE_UNSYNCED_HEIGHTMAP
	#include "Game/GlobalUnsynced.h" // for myAllyTeam
#endif
#include <algorithm>



CR_BIND(CLosMap, (int2(), false, nullptr))
CR_REG_METADATA(CLosMap, (
	CR_MEMBER(size),
	CR_MEMBER(map),
	CR_MEMBER(sendReadmapEvents)//,
	//CR_MEMBER(heightmap)
))







//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
/// CLosTables precalc helper

typedef std::vector<int2> LosLine;
typedef std::vector<LosLine> LosTable;

class CLosTables
{
public:
	static const LosTable& GetForLosSize(size_t losSize);

private:
	static CLosTables instance;
	std::vector<LosTable> lostables;

private:
	CLosTables();
	static LosLine GetRay(int x, int y);
	static LosTable GetLosRays(int radius);
	static void Debug(const LosTable& losRays, const std::vector<int2>& points, int radius);
	static std::vector<int2> GetCircleSurface(const int radius);
	static void AddMissing(LosTable& losRays, const std::vector<int2>& circlePoints, const int radius);
};

CLosTables CLosTables::instance;


const LosTable& CLosTables::GetForLosSize(size_t losSize)
{
	if (instance.lostables.size() <= losSize) {
		instance.lostables.resize(losSize+1);
	}

	LosTable& tl = instance.lostables[losSize];
	if (tl.empty() && losSize > 0)
		tl = std::move(GetLosRays(losSize));

	return tl;
}


CLosTables::CLosTables()
{
	lostables.reserve(128);
	lostables.emplace_back(); // zero radius
}


/**
 * @brief Precalcs the rays for LineOfSight raytracing.
 * In LoS we raytrace all squares in a radius if they are in view
 * or obstructed by the heightmap. To do so we cast rays with the
 * given radius to the LoS circle's surface. But cause those rays
 * have no width, it happens that squares are missed inside of the
 * circle. So these squares get their own rays with length < radius.
 *
 * Note: We only return the rays for the upper right sector, the
 * others can be constructed by mirroring.
 */
LosTable CLosTables::GetLosRays(const int radius)
{
	LosTable losRays;

	std::vector<int2> circlePoints = GetCircleSurface(radius);
	losRays.reserve(2 * circlePoints.size()); // twice cause of AddMissing()
	for (int2& p: circlePoints) {
		losRays.push_back(GetRay(p.x, p.y));
	}
	AddMissing(losRays, circlePoints, radius);

	//if (radius == 30)
	//	Debug(losRays, circlePoints, radius);
	losRays.shrink_to_fit();
	return losRays;
}


/**
 * @brief returns the surface coords of a 2d circle.
 * Note, we only return the upper right part, the other 3 are generated via mirroring.
 */
std::vector<int2> CLosTables::GetCircleSurface(const int radius)
{
	// Midpoint circle algorithm
	// returns the surface points of a circle (without duplicates)
	std::vector<int2> circlePoints;
	circlePoints.reserve(2 * radius);
	int x = radius;
	int y = 0;
	int decisionOver2 = 1 - radius;
	while (x >= y) {
		// the upper 1/8th
		circlePoints.emplace_back(x, y);

		// the lower 1/8th, not added when:
		// first check prevents 45deg duplicates
		// second makes sure that only (0,radius) or (radius, 0) is generated (they other one is generated by mirroring later)
		if (y != x && y != 0)
			circlePoints.emplace_back(y, x);

		y++;
		if (decisionOver2 <= 0) {
			decisionOver2 += 2 * y + 1;
		} else {
			x--;
			decisionOver2 += 2 * (y - x) + 1;
		}
	}
	assert(circlePoints.size() <= 2 * radius);
	return circlePoints;
}


/**
 * @brief Makes sure all squares in the radius are checked & adds rays to missing ones.
 */
void CLosTables::AddMissing(LosTable& losRays, const std::vector<int2>& circlePoints, const int radius)
{
	std::vector<bool> image((radius+1) * (radius+1), 0);
	auto setpixel = [&](int2 p) { image[p.y * (radius+1) + p.x] = true; };
	auto getpixel = [&](int2 p) { return image[p.y * (radius+1) + p.x]; };
	for (auto& line: losRays) {
		for (int2& p: line) {
			setpixel(p);
		}
	}

	// start the check from 45deg bisector and go from there to 0deg & 90deg
	// advantage is we only need to iterate once this time
	for (auto it = circlePoints.rbegin(); it != circlePoints.rend(); ++it) { // note, we reverse iterate the list!
		const int2& p = *it;
		for (int a=p.x; a>=1 && a>=p.y; --a) {
			int2 t1(a, p.y);
			int2 t2(p.y, a);
			if (!getpixel(t1)) {
				losRays.push_back(GetRay(t1.x, t1.y));
				for (int2& p_: losRays.back()) {
					setpixel(p_);
				}
			}
			if (!getpixel(t2) && t2 != int2(0,radius)) { // (0,radius) is a mirror of (radius,0), so don't add it
				losRays.push_back(GetRay(t2.x, t2.y));
				for (int2& p_: losRays.back()) {
					setpixel(p_);
				}
			}
		}
	}
}


/**
 * @brief returns line coords of a ray with zero width to the coords (xf,yf)
 */
LosLine CLosTables::GetRay(int xf, int yf)
{
	assert(xf >= 0);
	assert(yf >= 0);

	LosLine losline;
	if (xf > yf) {
		// horizontal line
		const float m = (float) yf / (float) xf;
		losline.reserve(xf);
		for (int x = 1; x <= xf; x++) {
			losline.emplace_back(x, Round(m*x));
		}
	} else {
		// vertical line
		const float m = (float) xf / (float) yf;
		losline.reserve(yf);
		for (int y = 1; y <= yf; y++) {
			losline.emplace_back(Round(m*y), y);
		}
	}

	assert(losline.back() == int2(xf,yf));
	assert(!losline.empty());
	return losline;
}


void CLosTables::Debug(const LosTable& losRays, const std::vector<int2>& points, int radius)
{
	// only one should be included (the other one is generated via mirroring)
	assert(losRays.front().back() == int2(radius, 0));
	assert(losRays.back().back() != int2(0,radius));

	// check for duplicated/included rays
	auto losRaysCopy = losRays;
	for (const auto& ray1: losRaysCopy) {
		if (ray1.empty())
			continue;

		for (auto& ray2: losRaysCopy) {
			if (ray2.empty())
				continue;

			if (&ray1 == &ray2)
				continue;

			// check if ray2 is part of ray1
			if (std::includes(ray1.begin(), ray1.end(), ray2.begin(), ray2.end())) {
				// prepare for deletion
				ray2.clear();
			}
		}
	}
	auto jt = std::remove_if(losRaysCopy.begin(), losRaysCopy.end(), [](LosLine& ray) { return ray.empty(); });
	assert(jt == losRaysCopy.end());

	// print the rays stats
	LOG("------------------------------------");

	// draw the sphere image
	LOG("- sketch -");
	std::vector<char> image((2*radius+1) * (2*radius+1), 0);
	auto setpixel = [&](int2 p, char value = 1) {
		image[p.y * (2*radius+1) + p.x] = value;
	};
	int2 midp = int2(radius, radius);
	for (auto& line: losRays) {
		for (int2 p: line) {
			setpixel(midp + p, 127);
			setpixel(midp - p, 127);
			setpixel(midp + int2(p.y, -p.x), 127);
			setpixel(midp + int2(-p.y, p.x), 127);
		}
	}
	for (int2 p: points) {
		setpixel(midp + p, 1);
		setpixel(midp - p, 2);
		setpixel(midp + int2(p.y, -p.x), 4);
		setpixel(midp + int2(-p.y, p.x), 8);
	}
	for (int y = 0; y <= 2*radius; y++) {
		std::string l;
		for (int x = 0; x <= 2*radius; x++) {
			if (image[y*(2*radius+1) + x] == 127) {
				l += ".";
			} else {
				l += IntToString(image[y*(2*radius+1) + x]);
			}
		}
		LOG("%s", l.c_str());
	}

	// points on the sphere surface
	LOG("- surface points -");
	std::string s;
	for (int2 p: points) {
		s += "(" + IntToString(p.x) + "," + IntToString(p.y) + ") ";
	}
	LOG("%s", s.c_str());

	// rays to those points
	LOG("- los rays -");
	for (auto& line: losRays) {
		std::string s;
		for (int2 p: line) {
			s += "(" + IntToString(p.x) + "," + IntToString(p.y) + ") ";
		}
		LOG("%s", s.c_str());
	}
	LOG_L(L_DEBUG, "------------------------------------");
}











//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
/// CLosMap implementation

void CLosMap::AddCircle(SLosInstance* instance, int amount)
{
	const int sx = std::max(         0, instance->basePos.x - instance->radius);
	const int ex = std::min(size.x - 1, instance->basePos.x + instance->radius);
	const int sy = std::max(         0, instance->basePos.y - instance->radius);
	const int ey = std::min(size.y - 1, instance->basePos.y + instance->radius);

	const int rr = Square(instance->radius);

#ifdef USE_UNSYNCED_HEIGHTMAP
	const bool updateUnsyncedHeightMap = (sendReadmapEvents && instance->allyteam >= 0 && (instance->allyteam == gu->myAllyTeam || gu->spectatingFullView));
	if (updateUnsyncedHeightMap) {
		const int LOS2HEIGHT_X = mapDims.mapx / size.x;
		const int LOS2HEIGHT_Z = mapDims.mapy / size.y;

		for (int lmz = sy; lmz <= ey; ++lmz) {
			const int rrx = rr - Square(instance->basePos.y - lmz);
			for (int lmx = sx; lmx <= ex; ++lmx) {
				if (Square(instance->basePos.x - lmx) > rrx) {
					continue;
				}

				const int losMapSquareIdx = (lmz * size.x) + lmx;
				const bool squareEnteredLOS = (map[losMapSquareIdx] == 0 && amount > 0);
				map[losMapSquareIdx] += amount;

				// update unsynced heightmap for all squares that
				// cover LOSmap square <x, y> (LOSmap resolution
				// is never greater than that of the heightmap)
				//
				// NOTE:
				//     CLosMap is also used by RadarHandler, so only
				//     update the unsynced heightmap from LosHandler
				//     (by checking if allyteam >= 0)
				//
				if (!squareEnteredLOS) { continue; }

				const int
					x1 = lmx * LOS2HEIGHT_X,
					z1 = lmz * LOS2HEIGHT_Z,
					x2 = std::min((lmx + 1) * LOS2HEIGHT_X, mapDims.mapxm1),
					z2 = std::min((lmz + 1) * LOS2HEIGHT_Z, mapDims.mapym1);

				readMap->UpdateLOS(SRectangle(x1, z1, x2, z2));
			}
		}

		return;
	}
#endif

	for (int lmz = sy; lmz <= ey; ++lmz) {
		const int rrx = rr - Square(instance->basePos.y - lmz);
		for (int lmx = sx; lmx <= ex; ++lmx) {
			if (Square(instance->basePos.x - lmx) > rrx) {
				continue;
			}

			map[(lmz * size.x) + lmx] += amount;
		}
	}
}

void CLosMap::AddRaycast(SLosInstance* instance, int amount)
{
	if (instance->squares.empty()) { //FIXME watch if unit has zero vision (underground etc.)
		LosAdd(instance->basePos, instance->radius, instance->baseHeight, instance->squares);
	}

#ifdef USE_UNSYNCED_HEIGHTMAP
	const bool updateUnsyncedHeightMap = (sendReadmapEvents && instance->allyteam >= 0 && (instance->allyteam == gu->myAllyTeam || gu->spectatingFullView));
	if (updateUnsyncedHeightMap) {
		const int LOS2HEIGHT_X = mapDims.mapx / size.x;
		const int LOS2HEIGHT_Z = mapDims.mapy / size.y;

		for (const int losMapSquareIdx: instance->squares) {
			const bool squareEnteredLOS = (map[losMapSquareIdx] == 0 && amount > 0);
			map[losMapSquareIdx] += amount;

			if (!squareEnteredLOS) { continue; }

			const int
				lmx = losMapSquareIdx % size.x,
				lmz = losMapSquareIdx / size.x;
			const int
				x1 = lmx * LOS2HEIGHT_X,
				z1 = lmz * LOS2HEIGHT_Z,
				x2 = std::min((lmx + 1) * LOS2HEIGHT_X, mapDims.mapxm1),
				z2 = std::min((lmz + 1) * LOS2HEIGHT_Z, mapDims.mapym1);

			readMap->UpdateLOS(SRectangle(x1, z1, x2, z2));
		}

		return;
	}
#endif

	for (const int losMapSquareIdx: instance->squares) {
		map[losMapSquareIdx] += amount;
	}
}



#define USE_FULL_HEIGHTMAP

#define MAP_SQUARE2(pos) (((pos).y << losHandler->los.mipLevel) * mapDims.mapx + ((pos).x << losHandler->los.mipLevel))
#define MAP_SQUARE(pos) ((pos).y * size.x + (pos).x)


void CLosMap::LosAdd(int2 pos, int radius, float baseHeight, std::vector<int>& squares)
{
	const float* heightmapFull = readMap->GetCenterHeightMapSynced();

	assert(radius > 0);
	if (radius <= 0) { return; }
	if (SRectangle(0,0,size.x,size.y).Inside(pos) && baseHeight <= heightmapFull[MAP_SQUARE2(pos)]) { return; }

	// add all squares that are in the los radius
	SRectangle safeRect(radius, radius, size.x - radius, size.y - radius);
	if (safeRect.Inside(pos)) {
		// we aren't touching the map borders -> we don't need to check for the map boundaries
		UnsafeLosAdd(pos, radius, baseHeight, squares);
	} else {
		// we need to check each square if it's outsid of the map boundaries
		SafeLosAdd(pos, radius, baseHeight, squares);
	}
}


void CLosMap::CastLos(std::vector<int>* squares, float* maxAng, const int2 pos, const int2 off, const float invR, float losHeight, std::vector<bool>& squaresMap, const int radius) const
{
	const float* heightmap2 = readMap->GetCenterHeightMapSynced();

	const int idx = MAP_SQUARE(pos + off);
	const int idx2 = MAP_SQUARE2(pos + off);
	const float bonusHeight = 5.f * invR;

	const float dh2 = heightmap2[idx2] - losHeight;
	float ang2 = dh2 * invR;
	if ((ang2 + bonusHeight) >= *maxAng) {
		const int2 oi = off + int2(radius, radius);
		if (!squaresMap[oi.y * (2*radius + 1) + oi.x]) {
			squares->push_back(idx);
			squaresMap[oi.y * (2*radius + 1) + oi.x] = true;
		}
		*maxAng = ang2;
		return;
	}

	const float dh = heightmap[idx] - losHeight;
	float ang = dh * invR;
	if ((ang + bonusHeight) >= *maxAng) {
		const int2 oi = off + int2(radius, radius);
		if (!squaresMap[oi.y * (2*radius + 1) + oi.x]) {
			squares->push_back(idx);
			squaresMap[oi.y * (2*radius + 1) + oi.x] = true;
		}
		*maxAng = ang;
	}
}


void CLosMap::UnsafeLosAdd(int2 pos, int radius, float losHeight, std::vector<int>& squares)
{
	const size_t area = Square((2*radius)+1);

	const LosTable& table = CLosTables::GetForLosSize(radius);
	size_t neededSpace = squares.size() + 1;
	for (const LosLine& line: table) {
		neededSpace += line.size() * 4;
	}
	neededSpace = std::min(neededSpace, area);
	squares.reserve(neededSpace);
	std::vector<bool> squaresMap(area, false); // used to filter duplicates
	squares.push_back(MAP_SQUARE(pos));
	for (const LosLine& line: table) {
		float maxAng[4] = {-1e7, -1e7, -1e7, -1e7};

		for (const int2& square: line) {
			const float invR = math::isqrt2(square.x*square.x + square.y*square.y);
			CastLos(&squares, &maxAng[0], pos, square,                    invR, losHeight, squaresMap, radius);
			CastLos(&squares, &maxAng[1], pos, -square,                   invR, losHeight, squaresMap, radius);
			CastLos(&squares, &maxAng[2], pos, int2(square.y, -square.x), invR, losHeight, squaresMap, radius);
			CastLos(&squares, &maxAng[3], pos, int2(-square.y, square.x), invR, losHeight, squaresMap, radius);
		}
	}
}


void CLosMap::SafeLosAdd(int2 pos, int radius, float losHeight, std::vector<int>& squares)
{
	const size_t area = Square((2*radius)+1);
	const LosTable& table = CLosTables::GetForLosSize(radius);
	size_t neededSpace = squares.size() + 1;
	for (const LosLine& line: table) {
		neededSpace += line.size() * 4;
	}
	neededSpace = std::min(neededSpace, area);
	squares.reserve(neededSpace);
	std::vector<bool> squaresMap(area, false); // used to filter duplicates

	SRectangle safeRect(0, 0, size.x, size.y);
	if (safeRect.Inside(pos)) {
		squares.push_back(MAP_SQUARE(pos));
	}

	for (const LosLine& line: table) {
		float maxAng[4] = {-1e7, -1e7, -1e7, -1e7};

		for (const int2 square: line) {
			const float invR = math::isqrt2(square.x*square.x + square.y*square.y);

			if (safeRect.Inside(pos + square)) {
				CastLos(&squares, &maxAng[0], pos, square,                    invR, losHeight, squaresMap, radius);
			}
			if (safeRect.Inside(pos - square)) {
				CastLos(&squares, &maxAng[1], pos, -square,                   invR, losHeight, squaresMap, radius);
			}
			if (safeRect.Inside(pos + int2(square.y, -square.x))) {
				CastLos(&squares, &maxAng[2], pos, int2(square.y, -square.x), invR, losHeight, squaresMap, radius);
			}
			if (safeRect.Inside(pos + int2(-square.y, square.x))) {
				CastLos(&squares, &maxAng[3], pos, int2(-square.y, square.x), invR, losHeight, squaresMap, radius);
			}
		}
	}
}
